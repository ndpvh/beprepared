import pandas as pd
import numpy as np
import math

# Add the QVEmod package to the system path. Needed to import corona_model as 
# a module
import sys
import os
filename = os.path.join(
    os.path.dirname(__file__),
    "../../dependencies/qvemod"
)

if not filename in sys.path:
    sys.path.append(filename)

# Import the needed classes from QVEmod
from corona_model.agent import Agent
from corona_model.environment import Environment
from corona_model.air import Wall, Shield, Void, EmissionPattern
from corona_model.actions import *
from corona_model.surfaces import Item, Fixture

from utility import select

# General function
#
# Function to be used on the general dataframe that results from the simulation 
# through predped.
def translate_data(time_series, 
                   agent_specifications):
    """"Translate time series to agents

    `QVEmod` depends on defining `Agent`s who perform a series of `Action`s. This 
    function takes the data generated by `predped` and then translates it to this 
    format. 

    Parameters
    ----------
    time_series : dataframe
        R data.frame to be transformed. Output of the `predped::simulate` and 
        `predped::time_series` functions.
    agent_specifications: dataframe
        R data.frame that contains the `id` of the agents and all of the 
        parameters required by `QVEmod`s `Agent` class. 

    Returns
    -------
    list
        a list of `Agent`s
    """

    # Transform the R dataframes to a pandas dataframe
    time_series = pd.DataFrame(time_series)
    agent_specifications = pd.DataFrame(agent_specifications)
    
    # We need to translate all actions for each of the individuals separately.
    # Get all of these individuals for the dataframe.
    agent_id = time_series['id'].unique()

    # Loop over the agents
    agents = []
    for i in agent_id:
        # Select data for this agent only
        df = time_series.loc[time_series['id'] == i].reset_index()

        # Loop over each row and translate the actions of the agent to what 
        # QVEmod expects
        actions = {}
        for j, row in df.iterrows():
            idx = int(df['iteration'][j] - 1)
            actions[idx] = translate_row(
                row,
                first_entry = j == 0
            )

        # Add the Agent to the list
        agent_args = select(agent_specifications, i)
        agents.append(
            Agent(
                i, 
                agent_args['viral_load'].values[0], 
                agent_args['contamination_load_air'].values[0], 
                agent_args['contamination_load_droplet'].values[0], 
                agent_args['contamination_load_surface'].values[0],
                agent_args['emission_rate_air'].values[0], 
                agent_args['emission_rate_droplet'].values[0], 
                agent_args['pick_up_air'].values[0], 
                agent_args['pick_up_droplet'].values[0],
                actions,
                wearing_mask = agent_args['wearing_mask'].values[0] == 1
            )
        )

    return agents

# Specific function for rows.
#
# Translates a single row in the dataframe to an Action that the agent has 
# performed. Necessary as input for QVEmod.
def translate_row(row, 
                  first_entry = False):
    """"Define action for single row in time-series

    `Parameters
    ----------
    row : pd.DataFrame
        Row in the `pd.DataFrame` containing the time-series.
    first_entry: boolean, optional
        Boolean denoting whether this is the first entry of the agent. If so, 
        the agent will be said to enter the space. Defaults to `False`.

    Returns
    -------
    Action
        an instance of the `Action` class
    """
    
    # Translate the actions of the agent in this row to one of the actions in 
    # the QVEmod implementation. Specifically, we make the translation:
    #   - first_entry == True   -> Enter
    #   - exit                  -> Leave
    #   - move                  -> Move
    #   - completing goal       -> Pickup, Face
    #   - plan, reroute,...     -> Face

    # Get the current action of the agent and define the direction in which they
    # are currently looking (QVEmod is discrete, while predped is continuous)
    action = row['status']

    direction = row['orientation']
    if (direction >= 45) & (direction < 135):
        direction = 'N'
    elif (direction >= 135) & (direction < 225):
        direction = 'W'
    elif (direction >= 225) & (direction < 315):
        direction = 'S'
    else:
        direction = 'E'

    # Handle the different cases
    match action:
        case 'move':
            if first_entry:
                return Enter(row['x'], row['y'], direction)
            
            if (row['x'] == 0) & (row['y'] == 0):
                return Face(direction)
            
            return Move(row['x'], row['y'], facing = direction)
        case 'exit':
            return Leave()
        case 'completing goal':
            if row['end_goal']:
                return Pickup(row['goal_id'])
            else:
                return Face(direction)
        case _:
            return Face(direction)
        
# Specific function for items.
#
# Function that takes in the general dataframe and, based on its input, creates
# all the items that contained in the environment.
def translate_items(time_series, 
                    item_specifications):
    """"Translate time series to items

    `QVEmod` depends on `Item`s that the agent can interact with. This function
    takes the data generated by `predped` and then translates all of the goals
    contained within this time=series to `Item`s that the agents interacted 
    with.

    Parameters
    ----------
    time_series : dataframe
        R data.frame to be transformed. Output of the `predped::simulate` and 
        `predped::time_series` functions.
    item_specifications: dataframe
        R data.frame that contains the `id` of the goals and all of the 
        parameters required by `QVEmod`s `Item` class. 

    Returns
    -------
    list
        a list of `Item`s
    """

    # Transform the R dataframes to a pandas dataframe
    time_series = pd.DataFrame(time_series)
    item_specifications = pd.DataFrame(item_specifications)
    
    # We need to translate all goals that have been observed to an Item. Get all
    # unique goals out of the dataframe.
    goal_id = time_series['goal_id'].unique()

    # Loop over the goals
    items = []
    for i in goal_id:
        # Select a single goal
        df = time_series.loc[time_series['goal_id'] == i]

        # Get the x and y coordinates for this goal
        x = df['goal_x'].values[0]
        y = df['goal_y'].values[0]

        # Create the item and add it to the list
        item_args = select(item_specifications, i)
        items.append(
            Item(
                i, 
                x, 
                y, 
                item_args['transfer_decay_rate'].values[0],
                item_args['surface_ratio'].values[0],
                item_args['surface_decay_rate'].values[0]
            )
        )

    return items

# Specific function for environments.
#
# Function that takes in dataframes
def translate_env(shape,
                  objects,
                  void_centers,
                  env_specifications):
    """"Translate background to environment

    `QVEmod` depends on an `Environment` that the agent is walking around in. 
    This function takes the specifications of the background and then translates 
    them to an `Environment`.

    Parameters
    ----------
    shape : dataframe
        R data.frame that contains all of the walls that make up the surrounding
        of the environment. Importantly, should contain a segment per row, 
        defined by an initial starting position ("x1", "y1") and an ending 
        position ("x2", "y2").
    objects: dataframe
        R data.frame that contains all of the barriers inside of the space. 
        In practice consists of all those objects that block contaminants.
        Importantly, should contain a segment per row, defined by an initial 
        starting position ("x1", "y1") and an ending position ("x2", "y2").
    void_centers: dataframe
        R data.frame that contains all positions that fall within inpenetrable 
        objects in its rows, having column names ("x", "y").
    env_specifications: dataframe
        R data.frame of a single row that contains all of the parameters
        required by `QVEmod`s `Environment` class. 

    Returns
    -------
    Environment
        instance of `Environment`
    """

    # Transform the R dataframes to a pandas dataframe
    shape = pd.DataFrame(shape)
    objects = pd.DataFrame(objects)
    env_specifications = pd.DataFrame(env_specifications)
    
    # Let's first determine the width and height of the environment. 
    width = np.ptp([shape['x1'], shape['x2']])
    height = np.ptp([shape['y1'], shape['y2']])

    # Make sure the width and height of the environment are integers.
    width = int(math.ceil(width))
    height = int(math.ceil(height))

    # Create a list of walls that make up the environment
    barriers = []
    for i, row in shape.iterrows():
        barriers.append(
            Wall(
                row['x1'], 
                row['y1'],
                row['x2'], 
                row['y2']
            )
        )

    # Now make a list of other barriers in the environment
    for i, row in objects.iterrows():
        barriers.append(
            Shield(
                row['x1'], 
                row['y1'],
                row['x2'], 
                row['y2']
            )
        )

    # Finally make those cells that fall within an object void. Needed to ensure
    # the correct contamination is computed by QVEmod
    walls = [Void(row['x'], row['y']) for i, row in void_centers.iterrows()]

    # With these defined, we will now combine all information into a singular 
    # `Environment` class, which we can then output as the result of the 
    # transformation
    return Environment(
        height, 
        width,
        env_specifications['decay_rate_air'].values[0], 
        env_specifications['decay_rate_droplet'].values[0], 
        env_specifications['decay_rate_surface'].values[0], 
        env_specifications['air_exchange_rate'].values[0],
        env_specifications['droplet_to_surface_transfer_rate'].values[0],
        barriers = barriers,
        walls = walls
    )

# Specific function for surfaces.
#
# Function that takes in an instance of the background-class and translates it 
# to the Environment class of QVEmod.
def translate_surf(objects,
                   surf_specifications):
    """"Translate objects to fixtures

    `QVEmod` depends on `Surface`s that the agent can interact with, or otherwise
    don't block any contaminants. This function takes the objects that have been
    defined as surfaces (in their `id`) and then translates them to a 
    `Fixture`.

    Parameters
    ----------
    objects: dataframe
        R data.frame that contains all of the surfaces inside of the space. 
        In practice consists of all those objects that do not block contaminants, 
        as indicated by the string "surface" in their `id`. Importantly, should 
        contain a a center position ("x", "y") and a ratio of their size. 
        Additionally needs to have an "id", allowing us attach the correct 
        specifications to the correct surface.
    surf_specifications: dataframe
        R data.frame of a single row that contains all of the parameters
        required by `QVEmod`s `Fixture` class. 

    Returns
    -------
    list
        list of `Fixture`s
    """

    # Transform the R dataframes to a pandas dataframe
    objects = pd.DataFrame(objects)
    surf_specifications = pd.DataFrame(surf_specifications)

    # Create a list of walls that make up the environment
    surfaces = []
    for i, row in objects.iterrows():
        # Create the Fixture and add to the list
        surf_args = select(surf_specifications, row['id'])
        surfaces.append(
            Fixture(
                row['id'],
                int(row['x']), 
                int(row['y']),
                surf_args['transfer_decay_rate'].values[0], 
                row['ratio'],
                surf_args['touch_frequency'].values[0], 
                surf_args['surface_decay_rate'].values[0]
            )
        )

    return surfaces