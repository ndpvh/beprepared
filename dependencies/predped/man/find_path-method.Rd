% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/goals.R
\name{find_path}
\alias{find_path}
\title{Find path to a goal}
\usage{
find_path(object, ...)
}
\arguments{
\item{object}{Object of \code{\link[predped]{goal-class}} for which the path
should be computed.}

\item{agent}{Object of \code{\link[predped]{agent-class}} who wants to move 
towards the goal defined in argument \code{object}.}

\item{background}{Object of \code{\link[predped]{background-class}} within 
which the goal and agent are contained.}

\item{space_between}{Numeric denoting the amount of space to leave between 
an object and a path point. Within this function, the default is the radius 
of the agent that is provided. However, in the \code{\link[predped]{simulate-method}}
function, this default is overwritten to be equal to \code{2.5} times this 
radius.}

\item{many_nodes}{Logical denoting whether to create many nodes or leave 
it at the minimum. Defaults to \code{FALSE}.}

\item{algorithm}{Character denoting the algorithm to be used for optimizing 
the path towards the goal. Is provided to the 
\code{\link[cppRouting]{get_path_pair}} function in the \code{cppRouting}
package. Defaults to \code{"Dijkstra"}. Note that one-way routing as 
controlled by the \code{limited_access} slot in the \code{background} may not 
work if a bidirectional algorithm is used.}

\item{precomputed_edges}{List containing the network of nodes and edges 
for the environment, as created by \code{\link[predped]{compute_edges}}. 
Defaults to \code{NULL}, triggering the creation of these edges again.}

\item{new_objects}{List of instances of \code{\link[predped]{object-class}} 
that are not yet contained in the \code{objects} slot in the argument 
\code{background}. Usually consists of other agents that the \code{agent}
has to account for when planning their route. Defaults to \code{NULL}.}

\item{reevaluate}{Logical denoting whether to reevaluate the network that is
provided in \code{precomputed_edges}. Is useful whenever \code{new_objects}
is not \code{NULL}, allowing us to check whether some nodes and edges are now
occluded by the new objects. Defaults to \code{FALSE}.}
}
\value{
Numerical matrix of coordinates representing the path points the 
agent will have to move to to reach the goal.
}
\description{
Creates a numerical matrix of coordinates which contain the path points that 
the agent will use to move towards a goal. It thus finds itself on the 
strategic level (when performed in an initial planning phase) and the tactical 
level (when performed in response to blockages).
}
\details{
Creates a numerical matrix containing coordinates of path points which, 
together, form a strategic path to the goal specified in this function. This
forms one of the functions that operate on the strategic and tactical level 
of the model.

To create this path, the function takes the following approach. First, it 
will create a network of nodes that are connected through unidirectional 
edges, as created by the \code{\link[predped]{create_edges}} function. 
Nodes are created based on the objects in the environment, so that the nodes
are always strategically placed at a certain distance away from the objects
in the environment (at a distance \code{space_between}). If the argument
\code{many_nodes = TRUE}, then a grid of other nodes are added to this 
list of initial nodes. This grid consists of nodes that are placed at an 
equal distance apart in the x- and y-direction, and spans 20 rows and 20 
columns. Once the nodes have been generated, those nodes that fall within 
any of the objects in the environment or falls outside of the environment 
are deleted. Unidirectional edges connect the different nodes and are 
similarly pruned based on intersections with objects or, when defined, 
intersections with instances of the \code{\link[predped]{segment-class}}.

Once the network of nodes and edges has been created, we translate this 
network into a graph that can be used by the \code{ccpRouting} package. 
Specifically, we use \code{\link[cppRouting]{makegraph}} for this purpose.
We then use the \code{\link[cppRouting]{get_path_pair}} function of the 
\code{cppRouting} package to find the shortest route to the goal. The user 
can specify which algorithm to use for this optimization through the argument 
\code{algorithm}, but the algorithm should be unidirectional to ensure that 
one-way walking can be enforced (as controlled through the \code{limited_access}
slot in the \code{\link[predped]{background-class}}).

Finally, the optimal path is checked for any redundancy and formatted so that 
the path points are contained in an n x 2 matrix.
}
\examples{
# Create a setting
my_background <- background(shape = rectangle(center = c(0, 0), 
                                              size = c(2, 2)),
                            objects = list(circle(center = c(0, 0), 
                                                  radius = 0.5)))

# Create an agent that is walking around there and a goal that the agent 
# will move to
my_goal <- add_goal(objects(my_background)[[1]], my_background)
my_agent <- agent(center = c(0.7, 0.7), radius = 0.25)

# Find the path of the agent to his goal
find_path(my_goal, 
          my_agent,
          my_background)

}
\seealso{
\code{\link[predped]{agent-class}}
\code{\link[predped]{background-class}}
\code{\link[predped]{goal-class}}
\code{\link[predped]{object-class}}
\code{\link[predped]{simulate}}
\code{\link[predped]{adjust_edges}}
\code{\link[predped]{compute_edges}}
\code{\link[predped]{create_edges}}
}
