# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Transform trace to time-series
#'
#' Rcpp alternative for \code{\link[predped]{time_series}}.
#' 
#' @param trace List of objects of the \code{\link[predped]{state-class}}
#' @param time_step Numeric denoting the time between each iteration. Defaults 
#' to \code{0.5} (the same as in \code{\link[predped]{simulate,predped-method}}).
#' 
#' @examples
#' # This is my example
#'
#' @rdname time_series_rcpp
#' 
#' @export
time_series_rcpp <- function(trace, time_step = 0.5) {
    .Call('_predped_time_series_rcpp', PACKAGE = 'predped', trace, time_step)
}

#' Transform trace to comprehensive data.frame
#' 
#' Rcpp alternative for the \code{\link[predped]{unpack_trace}} function.
#'
#' This function will take a trace and return a data.frame containing all 
#' information contained within a typical time-series (cfr. 
#' \code{\link[predped]{time_series}}) and with all the input that should be 
#' provided to the utility functions. This is therefore the primary function to 
#' use if you want to go from a trace to a data.frame that can be used in 
#' M4MA-based estimations.
#' 
#' @param trace List of objects of the \code{\link[predped]{state-class}}
#' @param velocities Numeric matrix containing the change in speed for an agent
#' whenever they move to the respective cell of this matrix. Is used to create 
#' the cell positions that the agent might move to, as performed through 
#' \code{\link[m4ma]{c_vd_rcpp}}. Currently limited to having 11 rows (direction) 
#' and 3 columns (speed). Defaults to a matrix in which the columns contain 
#' \code{1.5} (acceleration), \code{1}, and \code{0.5}.
#' @param orientations Numeric matrix containing the change in direction for an 
#' agent whenever they move to the respective cell of this matrix. Is used to 
#' create the cell positions that the agent might move to, as performed through
#' \code{\link[m4ma]{c_vd_rcpp}}. Currently limited to having 11 rows (direction)
#' and 3 columns (speed). Defaults to a matrix in which the rows contain 
#' \code{72.5}, \code{50}, \code{32.5}, \code{20}, \code{10}, code{0}, \code{350}, 
#' \code{340}, \code{327.5}, \code{310}, \code{287.5} (note that the larger 
#' angles are actually the negative symmetric versions of the smaller angles).
#' @param stay_stopped Logical denoting whether agents will predict others that 
#' are currently not moving to remain immobile in the next iteration. Defaults 
#' to \code{TRUE}.
#' @param time_step Numeric denoting the time between each iteration. Defaults 
#' to \code{0.5} (the same as in \code{\link[predped]{simulate,predped-method}}).
#' 
#' @examples
#' # This is my example
#'
#' @rdname unpack_trace_rcpp
#' 
#' @export
unpack_trace_rcpp <- function(trace, velocities, orientations, stay_stopped = TRUE, time_step = 0.5) {
    .Call('_predped_unpack_trace_rcpp', PACKAGE = 'predped', trace, velocities, orientations, stay_stopped, time_step)
}

unique <- function(x) {
    .Call('_predped_unique', PACKAGE = 'predped', x)
}

#' Compute the min-log-likelihood
#' 
#' Rcpp alternative to \code{\link[predped]{mll}}. Be wary: This version does 
#' not automatically add the motion variables to the data if not present in 
#' the data, nor does it do any of the other preprocessing. It is therefore 
#' better not used as an alternative to the R version, but rather as an 
#' extension of it (as done automatically in predped). 
#'
#' @param data List containing data.frames to use in the estimation procedure.
#' @param parameters List containing the parameters to be used.
#' Should be specified in the same order as specified in \code{"parameter_names"}. 
#' @param ids CharacterVector containing the names of the participants in the 
#' data set.
#' @param idx IntegerVector containing the index of the parameters to use to 
#' evaluate a given row in the data. Note that this index uses C++ convention.
#' Order should conform to the order in the list of the data.
#' @param cells IntegerVector denoting the cell to which a participant has 
#' moved at a given iteration. Order should conform to the order in the list of 
#' the data.
#' @param sizes IntegerVector containing the number of data points per person.
#' Ignored if \code{summed} is \code{TRUE}.
#' @param summed Boolean denoting whether to sum the min-log-likelihood to one
#' value per person. If \code{TRUE}, you get the resulting summed 
#' min-log-likelihood for each individual with a correction to avoid \code{-Inf}s.
#' If \code{FALSE}, the function will instead return a list of vectors containing
#' the raw likelihoods (not min-log-likelihoods!), allowing users to specify 
#' their own corrections (if needed).
#' 
#' @return Either named vector containing the summed min-log-likelihood 
#' (\code{summed = TRUE}) or named list with vectors of raw likelihoods
#' (\code{summed = FALSE}) per person in the dataset.
#' 
#' @export 
mll_rcpp <- function(data, parameters, ids, idx, cells, sizes, summed) {
    .Call('_predped_mll_rcpp', PACKAGE = 'predped', data, parameters, ids, idx, cells, sizes, summed)
}

psUtility <- function(a_preferred_speed, b_preferred_speed, preferred_speed, slowing_time, current_speed, goal_distance) {
    .Call('_predped_psUtility', PACKAGE = 'predped', a_preferred_speed, b_preferred_speed, preferred_speed, slowing_time, current_speed, goal_distance)
}

gaUtility <- function(b_goal_direction, a_goal_direction, goal_angles) {
    .Call('_predped_gaUtility', PACKAGE = 'predped', b_goal_direction, a_goal_direction, goal_angles)
}

caUtility <- function(b_current_direction, a_current_direction, blr_current_direction) {
    .Call('_predped_caUtility', PACKAGE = 'predped', b_current_direction, a_current_direction, blr_current_direction)
}

idUtility <- function(b_current_direction, d_current_direction, a_current_direction, id_ingroup, id_check, id_distance, impossible_utility) {
    .Call('_predped_idUtility', PACKAGE = 'predped', b_current_direction, d_current_direction, a_current_direction, id_ingroup, id_check, id_distance, impossible_utility)
}

baUtility <- function(a_blocked, b_blocked, ba_angle, cone_id) {
    .Call('_predped_baUtility', PACKAGE = 'predped', a_blocked, b_blocked, ba_angle, cone_id)
}

flUtility <- function(a_leader, b_leader, d_leader, leaders, distances) {
    .Call('_predped_flUtility', PACKAGE = 'predped', a_leader, b_leader, d_leader, leaders, distances)
}

wbUtility <- function(a_buddy, b_buddy, buddies, distances) {
    .Call('_predped_wbUtility', PACKAGE = 'predped', a_buddy, b_buddy, buddies, distances)
}

destinationAngle <- function(orientation, agent_position, goal_position) {
    .Call('_predped_destinationAngle', PACKAGE = 'predped', orientation, agent_position, goal_position)
}

predClose <- function(agent_idx, agent_position, orientation, others_position, radius, centers, predicted_positions, objects) {
    .Call('_predped_predClose', PACKAGE = 'predped', agent_idx, agent_position, orientation, others_position, radius, centers, predicted_positions, objects)
}

blockedAngle <- function(agent_position, orientation, speed, predictions_minus_agent, radii, objects) {
    .Call('_predped_blockedAngle', PACKAGE = 'predped', agent_position, orientation, speed, predictions_minus_agent, radii, objects)
}

bodyObjectOK <- function(radius, centers, objects, check) {
    .Call('_predped_bodyObjectOK', PACKAGE = 'predped', radius, centers, objects, check)
}

#' Check agent and object overlap
#' 
#' Rcpp alternative to \code{\link[predped]{overlap_with_objects}}. 
#' 
#' This function checks whether there is an overlap between a given agent and 
#' the objects in the environment, provided that the agent would move to the 
#' locations in \code{centers}. Returns a logical matrix as needed in 
#' \code{\link[predped]{moving_options-method}}.
#' 
#' @details
#' In this function, we can only approximately check the intersection of agent 
#' and object. Specifically, we use the following method. First, we sample 
#' nodes on the circumference of each of the objects in the setting that is 
#' provided to this function. For this, we depend on the function 
#' \code{\link[predped]{nodes_on_circumference}} and we currently take these 
#' nodes to be 5cm. 
#' 
#' In the next step, we bind all these coordinates together in a single matrix. 
#' This matrix thus consists of nodes that should not be embedded in the agents:
#' Whenever one of these points is included in the agents, we can conclude that
#' the agents and objects intersect. [Note, however, that if these points are 
#' not included in the agents, that we cannot with certainty conclude that agent 
#' and object do not intersect]
#' 
#' This check is then performed by looping over all the centers, changing the 
#' agents position to the position of this center, and using the 
#' \code{\link[predped]{in_object-method}} to do the test. This is a vectorized 
#' test: For each position in \code{centers} we have a logical \code{TRUE} or 
#' \code{FALSE} for each of the nodes in the coordinate matrix, resulting in a 
#' logical matrix with an equal number of rows as \code{centers} and an equal 
#' number of columns as nodes in the coordinate matrix. In a last step, 
#' we aggregate over the columns in this matrix so that we have a single logical
#' for each center.
#' 
#' The reason why we use this approximate method is because of time efficiency. 
#' Using the \code{\link[predped]{intersects-method}} takes a longer time than 
#' using the \code{\link[predped]{in_object-method}}, especially as the number 
#' of objects in the environment increases.
#' 
#' @param agent Object of the \code{\link[predped]{agent-class}}.
#' @param background Object of the \code{\link[predped]{background-class}}.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param check Logical matrix of dimensions 11 x 3 denoting whether an agent 
#' can move to a given cell (\code{TRUE}) or not (\code{FALSE}).
#' @param space_between Numeric denoting the space to leave between the nodes 
#' put on the circumference of the objects in the space (used for checking the
#' overlap with an agent). Defaults to \code{0.05} or 5cm.
#' 
#' @return Logical matrix containing availabilities of the centers (\code{TRUE}
#' if available, \code{FALSE} if not).
#' 
#' @examples 
#' # Initialize all objects that you need
#' my_background <- background(shape = rectangle(center = c(0, 0), 
#'                                               size = c(6, 6)), 
#'                             objects = list(circle(center = c(0, 0), 
#'                                                   radius = 2)))
#' my_agent <- agent(center = c(-2.75, 0), 
#'                   radius = 0.25, 
#'                   speed = 1, 
#'                   orientation = 0,
#'                   current_goal = goal(position = c(-2.01, 0)))
#' 
#' # Generate several locations the agent can move to
#' centers <- m4ma::c_vd_r(1:33, 
#'                         position(my_agent), 
#'                         speed(my_agent), 
#'                         orientation(my_agent))
#' check <- matrix(TRUE, nrow = 11, ncol = 3)
#' 
#' # Use moving_options to see which of these possibilities is sound
#' overlap_with_objects(my_agent, 
#'                      my_background,
#'                      centers,
#'                      check,
#'                      cpp = TRUE)
#' 
#' @seealso 
#' \code{\link[predped]{agent-class}},
#' \code{\link[predped]{background-class}},
#' \code{\link[predped]{in_object}},
#' \code{\link[predped]{intersects}},
#' \code{\link[predped]{moving_options}},
#' \code{\link[predped]{nodes_on_circumference}}
#' 
#' @rdname overlap_with_objects_rcpp
#' 
#' @export
overlap_with_objects_rcpp <- function(agent, background, centers, check, space_between = 5e-2) {
    .Call('_predped_overlap_with_objects_rcpp', PACKAGE = 'predped', agent, background, centers, check, space_between)
}

#' Check where an object can be moved to
#'
#' Rcpp alternative to \code{\link[predped]{moving_options}}. This method checks 
#' where an object can be moved to. It returns a logical matrix that codes 
#' \code{TRUE} for the cells that are available and \code{FALSE} for those that 
#' aren't.
#' 
#' @details
#' In general, this method works as follows. First, it checks whether any of the 
#' provided cell centers are freely available, in the sense that they are not 
#' contained inside any objects or fall outside of the setting. This is a crude
#' measure of whether a particular spot is available and is handled by the 
#' \code{\link[m4ma]{free_cells_rcpp}} function of the \code{m4ma} package.
#' 
#' Second, we check whether the object itself can be moved to this space, or 
#' whether it would intersect with any of the objects and/or the outline of the 
#' setting. This is a more direct measure of availability, as it doesn't only 
#' account for whether a specific spot can be reached theoretically, but also 
#' accounts for the size of the object that is being moved there. This is 
#' handled by the \code{\link[predped]{overlap_with_objects}} function in 
#' \code{predped}.
#' 
#' Finally, if the object is an instance of the \code{\link[predped]{agent-class}}, 
#' we also check whether the agent can still see there current goal or path-point
#' when they move to the open spots. They will not move to the spots from which
#' they cannot see their goal/path-point. This is handled by the 
#' \code{\link[m4ma]{seesGoalOK_rcpp}} function in the \code{m4ma} package.
#' 
#' WARNING: Due to its reliance on the \code{m4ma} package, centers needs to be 
#' of length 33 x 2. This corresponds to the 3 (change in speed) x 11 
#' (change in orientation) options that are inherent to M4MA.
#'
#' @param object Object of the \code{\link[predped]{agent-class}} or the 
#' \code{\link[predped]{object-class}} (latter not yet supported).
#' @param state Object of the \code{\link[predped]{state-class}} containing the 
#' current state.
#' @param background Object of the \code{\link[predped]{background-class}}.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#'
#' @return Logical matrix containing availabilities of the centers.
#' 
#' @examples 
#' # Initialize all objects that you need
#' my_background <- background(shape = rectangle(center = c(0, 0), 
#'                                               size = c(6, 6)), 
#'                             objects = list(circle(center = c(0, 0), 
#'                                                   radius = 2)))
#' my_agent <- agent(center = c(-2.75, 0), 
#'                   radius = 0.25, 
#'                   speed = 1, 
#'                   orientation = 0,
#'                   current_goal = goal(position = c(-2.01, 0)))
#' 
#' my_state <- state(iteration = 1,
#'                   setting = my_background, 
#'                   agents = list())
#' 
#' # Generate several locations the agent can move to
#' centers <- m4ma::c_vd_r(1:33, 
#'                         position(my_agent), 
#'                         speed(my_agent), 
#'                         orientation(my_agent))
#' 
#' # Use moving_options to see which of these possibilities is sound
#' moving_options(my_agent, 
#'                my_state, 
#'                my_background,
#'                centers,
#'                cpp = TRUE)
#' 
#' @seealso 
#' \code{\link[predped]{agent-class}},
#' \code{\link[predped]{background-class}},
#' \code{\link[predped]{object-class}},
#' \code{\link[predped]{state-class}},
#' \code{\link[predped]{overlap_with_objects}} 
#'
#' @docType methods
#' 
#' @rdname moving_options_rcpp
#'
#' @export
moving_options_rcpp <- function(agent, state, background, centers) {
    .Call('_predped_moving_options_rcpp', PACKAGE = 'predped', agent, state, background, centers)
}

#' Add Nodes on the Circumference of an Object
#' 
#' Rcpp alternative of \code{\link[predped]{nodes_on_circumference}}.
#' 
#' Used in the \code{\link[predped]{overlap_with_objects}} function for creating 
#' nodes of which their presence within an agent can be checked in an efficient 
#' way (see \code{\link[predped]{moving_options-method}} and 
#' \code{\link[predped]{in_object-method}}). Currently works for all 
#' instances of \code{\link[predped]{object-class}}, but only returns 
#' \code{NULL} for the \code{\link[predped]{segment-class}}.
#' 
#' @details 
#' Related to the \code{\link[predped]{add_nodes-method}} with the main difference
#' being that the \code{\link[predped]{add_nodes-method}} adds nodes around or 
#' within an object, while \code{nodes_on_circumference} adds nodes directly on
#' the circumference of an object.
#' 
#' Note that while \code{\link[predped]{rectangle-class}} is not explicitly 
#' mentioned here, this method does work for this class of objects.
#'
#' @param object Object of \code{\link[predped]{object-class}}.
#' @param space_between Numeric denoting the space to leave between the 
#' circumference of the object and the nodes to create. When \code{outside = TRUE},
#' \code{space_between} distance is created to the outside of the object, while
#' if \code{outside = FALSE} this same distance is created towards the inside 
#' of the object. Defaults to \code{5e-2}.
#'
#' @return Numerical matrix containing the nodes that were created around/within
#' the provided object.
#' 
#' @examples 
#' # Create an object
#' my_circle <- circle(center = c(0, 0), radius = 1)
#' 
#' # Generate nodes that fall around this circle with a distance of 1 around 
#' # the circle
#' nodes_on_circumference(my_circle, space_between = pi / 2, cpp = TRUE)
#' 
#' @seealso 
#' \code{\link[predped]{circle-class}}, 
#' \code{\link[predped]{polygon-class}},  
#' \code{\link[predped]{rectangle-class}},
#' \code{\link[predped]{segment-class}},
#' \code{\link[predped]{add_nodes}},
#' \code{\link[predped]{in_object}}, 
#' \code{\link[predped]{moving_options}}
#' 
#' @docType method
#' 
#' @rdname nodes_on_circumference_rcpp
#' 
#' @export
nodes_on_circumference_rcpp <- function(object, space_between) {
    .Call('_predped_nodes_on_circumference_rcpp', PACKAGE = 'predped', object, space_between)
}

#' Check Whether a Point Lies Within an Object
#' 
#' Currently works for all classes inside of the \code{\link[predped]{object-class}}.
#'
#' @param object Object of the \code{\link[predped]{object-class}}.
#' @param x Numeric vector or matrix containing x- and y-coordinates to be 
#' checked.
#'
#' @return Logical whether the point is inside of the object (\code{TRUE}) or 
#' outside of the object (\code{FALSE}).
#' 
#' @examples 
#' # Create an object
#' my_circle <- circle(center = c(0, 0), radius = 1)
#' 
#' # Let's create a matrix of different coordinates of which the first is 
#' # inside of the object, the second on its circumference, and the third  
#' # outside of the object
#' coords <- rbind(c(0, 0), 
#'                 c(1, 0), 
#'                 c(2, 0))
#' 
#' # Let's do the test
#' in_object_rcpp(my_circle, coords)
#' 
#' @seealso 
#' \code{\link[predped]{circle-class}}, 
#' \code{\link[predped]{polygon-class}},  
#' \code{\link[predped]{rectangle-class}},
#' \code{\link[predped]{segment-class}},
#' \code{\link[predped]{out_object}}, 
#' \code{\link[predped]{moving_options}}
#' 
#' @docType method
#' 
#' @rdname in_object_rcpp
#' 
#' @export
in_object_rcpp <- function(object, x) {
    .Call('_predped_in_object_rcpp', PACKAGE = 'predped', object, x)
}

#' Predict agents' movement
#' 
#' Rcpp alternative of \code{\link[predped]{predict_movement}}.
#'
#' Uses the agents' current speed and orientation to determine where the agent 
#' might end up in the next step, assuming that they do not change direction or 
#' speed. This information is used by other agents to determine where (not) to 
#' go to avoid collisions.
#' 
#' @param agent Object of the \code{\link[predped]{agent-class}}.
#' @param stay_stopped Logical denoting whether agents will predict others that 
#' are currently not moving to remain immobile in the next iteration. Defaults 
#' to \code{TRUE}.
#' @param time_step Numeric denoting the number of seconds each discrete step in
#' time should mimic. Defaults to \code{0.5}, or half a second.
#' 
#' @return Numeric matrix containing the predicted positions all agents if 
#' they all maintain their speed and direction.
#' 
#' @seealso 
#' \code{\link[predped]{create_agent_specifications}},
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}}
#' 
#' @rdname predict_movement_rcpp
#' 
#' @export
predict_movement_rcpp <- function(agent, stay_stopped = TRUE, time_step = 0.5) {
    .Call('_predped_predict_movement_rcpp', PACKAGE = 'predped', agent, stay_stopped, time_step)
}

#' Create agent specifications
#' 
#' Rcpp alternative to the \code{\link[predped]{create_agent_specifications}} 
#' function.
#'
#' This list translates the information available in the \code{agents} slot of
#' the current status of the \code{\link[predped]{state-class}} to a list 
#' with all this information in numeric vectors or matrices instead of inside 
#' objects. Allows for a translation from the object-oriented way of doing things
#' in \code{predped} to the vectorized way of doing things in \code{m4ma}.
#'
#' @param agent Object of the \code{\link[predped]{agent-class}}.
#' @param stay_stopped Logical denoting whether agents will predict others that 
#' are currently not moving to remain immobile in the next iteration. Defaults 
#' to \code{TRUE}.
#' @param time_step Numeric denoting the number of seconds each discrete step in
#' time should mimic. Defaults to \code{0.5}, or half a second.
#' 
#' @return List containing all information of all agents within the current 
#' state.
#' 
#' @seealso 
#' \code{\link[predped]{create_agent_specifications}},
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}}
#' 
#' @rdname create_agent_specifications_rcpp
#' 
#' @export
create_agent_specifications_rcpp <- function(agent_list, stay_stopped = TRUE, time_step = 0.5) {
    .Call('_predped_create_agent_specifications_rcpp', PACKAGE = 'predped', agent_list, stay_stopped, time_step)
}

#' Distances to group centroid
#'
#' Rcpp version of \code{\link[predped]{distance_group_centroid}}. 
#' 
#' Compute the distance of a given agent to the group centroid. This group 
#' centroid is computed as a summary statistic of the predicted x- and y-
#' coordinates of all pedestrians belonging to the same group as the agent. The 
#' summary statistic of choice should be one of mean-tendency, but can be 
#' specified by the user through the argument \code{fx}.
#' 
#' Note that this function has been defined to be in line with the \code{m4ma}
#' utility functions.
#'
#' @param p_pred Numeric matrix with shape N x 2 containing predicted positions
#' of all pedestrians that belong to the social group of the agent.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param nped Numeric integer indicating number of people in pedestrian `n`'s social group. 
#' @param fx Function used to find the group centroid. Defaults to \code{mean}
#'
#' @return Numeric vector containing the distance from each cell in the `center`
#' to the group centroid. If not other agents belong to the same group as the 
#' agent, returns \code{NULL}.
#' 
#' @seealso 
#' \code{\link[predped]{gc_utility}},
#' \code{\link[predped]{utility}}
#' 
#' @rdname distance_group_centroid_rcpp
#'
#' @export 
distance_group_centroid_rcpp <- function(predictions, centers, number_agents) {
    .Call('_predped_distance_group_centroid_rcpp', PACKAGE = 'predped', predictions, centers, number_agents)
}

#' Angle between agent and group members
#' 
#' Finds the angle at which the group members are located compared to the agent.
#' Uses the predicted positions of the group members for this.
#'
#' @param agent_idx Numeric denoting the position of the agent in the prediction 
#' matrix \code{p_pred}.
#' @param agent_group Numeric vector with the group membership of all 
#' pedestrians.
#' @param position Numeric vector denoting the current position of the agent.
#' @param orientation Numeric denoting the current orientation of the agent.
#' @param p_pred Numeric matrix with shape N x 2 containing predicted positions
#' of all pedestrians that belong to the social group of the agent.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param any_member Logical denoting whether to consider the angles of all 
#' group members (\code{TRUE}) -- effectively saying that it doesn't matter 
#' which group member the agent can see, as long as they can see one -- or 
#' whether to only consider the nearest group member (\code{FALSE}). Defaults 
#' to \code{TRUE}.
#'
#' @return Numeric vector containing the relative angle of the group member(s)
#' compared to the orientation of the agent within a given cell in \code{centers}.
#' 
#' @seealso 
#' \code{\link[predped]{utility}}
#' \code{\link[predped]{vf_utility_continuous}}
#' \code{\link[predped]{vf_utility_discrete}}
#' 
#' @rdname get_angles_rcpp
#' 
#' @export 
get_angles_rcpp <- function(agent_idx, agent_groups, position, orientation, predictions, centers, any_member = TRUE) {
    .Call('_predped_get_angles_rcpp', PACKAGE = 'predped', agent_idx, agent_groups, position, orientation, predictions, centers, any_member)
}

#' Compute utility variables
#' 
#' Rcpp version of the \code{\link[predped]{compute_utility_variables}} function.
#' 
#' @param object Object of the \code{\link[predped]{agent-class}}.
#' @param state Object of the \code{\link[predped]{state-class}}.
#' @param background Object of the \code{\link[predped]{background-class}}.
#' @param agent_specifications List created by the 
#' \code{\link[predped]{create_agent_specifications}} function. Contains all 
#' information of all agents within the current \code{state} and allows for the
#' communication between the \code{predped} simulation functions and the 
#' \code{m4ma} utility functions.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param check Logical matrix of dimensions 11 x 3 denoting whether an agent 
#' can move to a given cell (\code{TRUE}) or not (\code{FALSE}).
#' 
#' @return Data.frame containing all of the needed variables to be able to 
#' compute the values of the utility functions.
#' 
#' @seealso 
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}},
#' \code{\link[predped]{update_position}},
#' \code{\link[predped]{update}}
#' 
#' @rdname compute_utility_variables_rcpp
#' 
#' @export 
compute_utility_variables_rcpp <- function(agent, state, background, agent_specifications, centers, check_original) {
    .Call('_predped_compute_utility_variables_rcpp', PACKAGE = 'predped', agent, state, background, agent_specifications, centers, check_original)
}

#' Group centroid utility
#'
#' Rcpp alternative for the group centroid utility function. 
#' 
#' @param a_gc Numeric denoting the power to which to take the utility.
#' @param b_gc Numeric denoting the slope of the utility function.
#' @param radius Numeric denoting the radius of the agent.
#' @param cell_dist Numeric vector denoting the distance of each cell in the 
#' \code{centers} to the predicted group centroid.
#' @param stop_utility Numeric denoting the utility of stopping. Is used to 
#' ensure the agents do not freeze when they are too far away from each other. 
#' @param nped Numeric denoting the number of ingroup members. 
#' 
#' @return Numeric vector containing the group-centroid-related utility for each 
#' cell. 
#' 
#' @seealso 
#' \code{\link[predped]{distance_group_centroid}},
#' \code{\link[predped]{params_from_csv}},
#' \code{\link[predped]{utility}}
#' 
#' @rdname gc_utility_rcpp
#' 
#' @export
gc_utility_rcpp <- function(a_group_centroid, b_group_centroid, radius, cell_distances, stop_utility, nped) {
    .Call('_predped_gc_utility_rcpp', PACKAGE = 'predped', a_group_centroid, b_group_centroid, radius, cell_distances, stop_utility, nped)
}

#' Discrete visual field utility
#' 
#' Rcpp alternative to the \code{vf_utility_discrete} function.
#' 
#' The idea of this utility function is that it doesn't matter at which angle 
#' you see a group member within the visual field, as long as you see them. 
#' This translates to a discrete added disutility whenever the group member 
#' falls inside the non-visual zone behind the agent.
#' 
#' @param b_vf Numeric denoting the slope of the utility function. 
#' @param rel_angles Numeric vector containing the relative angle from each cell 
#' center to the predicted positions of the group members. Typically output of 
#' \code{\link[predped]{get_angle}}. 
#' 
#' @return Numeric vector containing the utility attributed to keeping the 
#' group members within your visual field. Returns 0's if the agent does not 
#' have any additional group members.
#' 
#' @seealso 
#' \code{\link[predped]{get_angles}},
#' \code{\link[predped]{utility}},
#' \code{\link[predped]{vf_utility_continuous}}
#' 
#' @rdname vf_utility_rcpp
#' 
#' @export
vf_utility_rcpp <- function(b_visual_field, relative_angles) {
    .Call('_predped_vf_utility_rcpp', PACKAGE = 'predped', b_visual_field, relative_angles)
}

#' Utility
#'
#' This function is the Rcpp equivalent of \code{\link[predped]{utility}}. It
#' takes in a dataframe containing all of the relevant values for computing the
#' utility, as well as a dataframe containing the parameters. Heavily depends 
#' on the \code{m4ma} package.
#' 
#' @param object Dataframe containing all of the needed information to compute 
#' the utilities. Typically output of the 
#' \code{\link[predped]{compute_utility_variables}} function.
#' @param parameters Dataframe containing the parameters of the agent. Should 
#' conform to the naming conventions mentioned in 
#' \code{\link[predped]{params_from_csv}}.
#' 
#' @return Numeric vector denoting the (dis)utility of moving to each of the 
#' potential cells.
#' 
#' @seealso 
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}},
#' \code{\link[predped]{utility,agent-method}},
#' \code{\link[predped]{compute_utility_variables}},
#' \code{\link[predped]{params_from_csv}},
#' \code{\link[predped]{update_position}}
#' 
#' @rdname utility_rcpp
#' 
utility_rcpp <- function(data, parameters) {
    .Call('_predped_utility_rcpp', PACKAGE = 'predped', data, parameters)
}

#' Utility
#'
#' This function is the Rcpp equivalent of \code{\link[predped]{utility}}. 
#' This function uses the operational-level utility functions to compute the 
#' utility of moving to any given potential cell in \code{centers}. Here, we 
#' assume that none of the utility variables (i.e., the variables that serve as 
#' input to the utility functions) is precomputed, so that it will first compute
#' their values. This input is then provided to 
#' \code{\link[predped]{utility,data.frame-method}} for the actual computation 
#' of the utility.
#' 
#' @param object Object of the \code{\link[predped]{agent-class}}.
#' @param state Object of the \code{\link[predped]{state-class}}.
#' @param background Object of the \code{\link[predped]{background-class}}.
#' @param agent_specifications List created by the 
#' \code{\link[predped]{create_agent_specifications}} function. Contains all 
#' information of all agents within the current \code{state} and allows for the
#' communication between the \code{predped} simulation functions and the 
#' \code{m4ma} utility functions.
#' @param centers Numerical matrix containing the coordinates at each position
#' the object can be moved to. Should have one row for each cell.
#' @param check Logical matrix of dimensions 11 x 3 denoting whether an agent 
#' can move to a given cell (\code{TRUE}) or not (\code{FALSE}).
#' @param cpp Logical denoting whether to use the Rcpp version of the function
#' (\code{TRUE}) or the R version (\code{FALSE}). Defaults to \code{TRUE}.
#' 
#' @return Numeric vector denoting the (dis)utility of moving to each of the 
#' cells in \code{centers}.
#' 
#' @seealso 
#' \code{\link[predped]{simulate,predped-method}},
#' \code{\link[predped]{simulate,state-method}},
#' \code{\link[predped]{update,agent-method}},
#' \code{\link[predped]{update,state-method}},
#' \code{\link[predped]{utility,data.frame-method}},
#' \code{\link[predped]{compute_utility_variables}},
#' \code{\link[predped]{update_position}}
#' 
#' @rdname utility_agent_rcpp
#' 
#' @export
utility_agent_rcpp <- function(agent, state, background, agent_specifications, centers, check) {
    .Call('_predped_utility_agent_rcpp', PACKAGE = 'predped', agent, state, background, agent_specifications, centers, check)
}

